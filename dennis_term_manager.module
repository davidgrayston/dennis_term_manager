<?php

/**
 * @file
 * Module file Dennis Term Manager. 
 */

define('DENNIS_TERM_MANAGER_ACTION_CREATE', 'create');
define('DENNIS_TERM_MANAGER_ACTION_DELETE', 'delete');
define('DENNIS_TERM_MANAGER_ACTION_MERGE', 'merge');
define('DENNIS_TERM_MANAGER_ACTION_RENAME', 'rename');
define('DENNIS_TERM_MANAGER_ACTION_MOVE_PARENT', 'move parent');

/**
 * Implements hook_views_api().
 */
function dennis_term_manager_views_api() {
  return array(
    'api' => 3.0,
    'path' => drupal_get_path('module', 'dennis_term_manager')
  );
}

/**
 * Implements hook_permission().
 */
function dennis_term_manager_permission() {
  return array(
    'administer dennis term manager' => array(
      'title' => t('Administer term manager'),
      'description' => t('Manage Dennis taxonomy terms CSV bulk operation'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function dennis_term_manager_menu() {
  $items = array();
  $weight = 0;
  $items['admin/structure/taxonomy/term_manager'] = array(
    'title' => 'Term Manager',
    'description' => 'Manage bulk taxonomy term operation via CSV file upload',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'dennis_term_manager_form',
    ),
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/manage'] = array(
    'title' => 'Manage',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/export_tsv'] = array(
    'title' => 'TSV Export',
    'description' => 'Download tab separated data',
    'page callback' => 'dennis_term_manager_export_terms',
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/export_csv'] = array(
    'title' => 'CSV Export',
    'description' => 'Download comma separated data',
    'page callback' => 'dennis_term_manager_export_terms',
    'page arguments' => array(','),
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/template_tsv'] = array(
    'title' => 'TSV Template',
    'description' => 'Download tab separated template',
    'page callback' => 'dennis_term_manager_download_template',
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  $items['admin/structure/taxonomy/term_manager/template_csv'] = array(
    'title' => 'CSV Template',
    'description' => 'Download comma separated template',
    'page callback' => 'dennis_term_manager_download_template',
    'page arguments' => array(','),
    'access arguments' => array(
      'administer dennis term manager',
    ),
    'type' => MENU_LOCAL_TASK,
    'weight' => $weight++,
  );
  return $items;
}

/**
 * Download CSV/TSV template.
 */
function dennis_term_manager_download_template($delimiter = "\t") {
  // Send correct header to download file.
  $extension = $delimiter == ',' ? 'csv' : 'tsv';
  drupal_add_http_header('Content-Type', 'text/' . $extension . '; utf-8');
  $file_name = 'taxonomy_template_' . date('Y-m-d_H-i-s') . '.' . $extension;
  drupal_add_http_header('Content-Disposition', 'attachment; filename=' . $file_name);

  $columns = dennis_term_manager_default_columns();
  $out = fopen('php://output', 'w');
  fputcsv($out, $columns, $delimiter, '"');
}

/**
 * Get existing taxonomy usage.
 */
function _dennis_term_manager_export_terms_query() {
  $query = db_select('taxonomy_term_data', 't');

  // Term vocabulary and name.
  $query->addField('v', 'name', 'vocabulary_name');
  $query->addField('t', 'name', 'term_name');

  // TID and VID
  $query->addField('v', 'vid', 'vid');
  $query->addField('t', 'tid', 'tid');

  // Get node count for term.
  $query->addExpression('(SELECT COUNT(1) FROM taxonomy_index i WHERE i.tid = t.tid)', 'node_count');

  // Parent term name.
  $query->addExpression('IF(p.name IS NULL, \'\', p.name)', 'parent_term_name');

  // Join on vocabulary of term.
  $query->leftJoin('taxonomy_vocabulary', 'v', 'v.vid = t.vid');

  // Parent information.
  $query->leftJoin('taxonomy_term_hierarchy', 'h', 'h.tid = t.tid');
  $query->leftJoin('taxonomy_term_data', 'p', 'p.tid = h.parent');

  // Group by tid to get node counts for each term.
  $query->groupBy('t.tid');

  return $query;
}

/**
 * Export current taxonomy.
 */
function dennis_term_manager_export_terms($delimiter = "\t") {
  $query = _dennis_term_manager_export_terms_query();
  $result = $query->execute();

  // Send correct header to download file.
  $extension = $delimiter == ',' ? 'csv' : 'tsv';
  drupal_add_http_header('Content-Type', 'text/' . $extension . '; utf-8');
  $file_name = 'taxonomy_export_' . date('Y-m-d_H-i-s') . '.' . $extension;
  drupal_add_http_header('Content-Disposition', 'attachment; filename=' . $file_name);

  // Add default CSV/TSV headings.
  $columns = dennis_term_manager_default_columns();
  $out = fopen('php://output', 'w');
  fputcsv($out, $columns, $delimiter, '"');

  while ($row = $result->fetchObject()) {
    // Add report data to corresponding column.
    $row_data = array();
    foreach ($columns as $column) {
      $row_data[] = isset($row->{$column}) ? $row->{$column} : '';
    }
    fputcsv($out, $row_data, $delimiter, '"');
  }
}

/**
 * Implements hook_help().
 */
function dennis_term_manager_help($path, $arg) {
  switch ($path) {
    case 'admin/structure/taxonomy/term_manager':
    case 'admin/help#dennis_term_manager':
      $output = '';
      $output .= '<div class="import-notes">';
      $output .= '<span>' . t('Make sure the file is in CSV or TSV format with the following headings.') . '</span>';
      $output .= '<table><tr>';
      $output .= '<td>' . implode('</td><td>', dennis_term_manager_default_columns()) . '</td>';
      $output .= '</tr></table>';
      $output .= '</div>';
      return $output;
  }
}

/**
 * Dennis Term Manager Form.
 */
function dennis_term_manager_form($form, &$form_state) {
  $form = array();

  // Display current process.
  if ($item = dennis_term_manager_get_current_queue_item()) {
    $report_file = file_load($item->data['report_fid']);
    $message = t('There is currently an active process. !report_link &raquo;', array(
      '!report_link' => l('View report', file_create_url($report_file->uri)),
    ));
    drupal_set_message($message, 'warning');
  }

  // Store CSV/TSV files and reports in private file location if available.
  if (variable_get('file_private_path', '')) {
    $location = 'private://';
  }
  else {
    $location = 'public://';
    // Warn user that files will be publicly accessible.
    $config_link = l(
        'Please configure the private file system path to store report privately',
        'admin/config/media/file-system'
    );
    $warning_message = t('Files will be stored in the public file directory. !config_link', array('!config_link' => $config_link));
    drupal_set_message($warning_message, 'warning');
  }
  $form['csv_file'] = array(
    '#title' => t('Import'),
    '#type' => 'managed_file',
    '#description' => t('The CSV file to be processed.'),
    '#upload_validators' => array('file_validate_extensions' => array('csv tsv')),
    '#upload_location' => $location,
  );

  $form['buttons']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Import'),
    '#suffix' => '<span> ' . t('Click the "Upload" button to process the file.') . '</span>',
  );
  $form['from'] = array(
    '#type' => 'item',
    '#prefix' => '<div><br /></div>',
    '#title' => t('Reports'),
    '#markup' => views_embed_view('csv_report'),
  );

  return $form;
}

/**
 * Callback function for form submission.
 *
 * @param object $form
 *   Form Object
 * @param object $form_state
 *   Form State
 */
function dennis_term_manager_form_submit(&$form, &$form_state) {
  // Load the file.
  $file = file_load($form_state['values']['csv_file']);
  if (!$file) {
    drupal_set_message(t('file not found'));
  }
  else {
    // Make file permanent.
    $file->status = FILE_STATUS_PERMANENT;
    file_save($file);

    // Add file usage.
    file_usage_add($file, 'dennis_term_manager', 'dennis_term_manager_csv_file', 1);

    // Set initial counter for debug information.
    $_SESSION['http_request_count'] = 0;

    // Process the file.
    $batch = _dennis_term_manager_batch_init($file);
    batch_set($batch);
  }
}

/**
 * Implements hook_file_download().
 *
 * Handle private file permissions.
 */
function dennis_term_manager_file_download($uri, $field_type = 'file') {
  // Get the file record based on the URI. If not in the database just return.
  $files = file_load_multiple(array(), array('uri' => $uri));
  if (count($files)) {
    foreach ($files as $item) {
      // Since some database servers sometimes use a case-insensitive comparison
      // by default, double check that the filename is an exact match.
      if ($item->uri === $uri) {
        $file = $item;
        break;
      }
    }
  }
  if (!isset($file)) {
    return;
  }

  // If the file is used by dennis_term_manager, check that the current user has access.
  $usage = file_usage_list($file);
  if (isset($usage['dennis_term_manager']['dennis_term_manager_csv_file'])) {
    if (user_access('administer dennis term manager')) {
      // Grant access to user with term manager permissions.
      $headers = file_get_content_headers($file);
      return $headers;
    }
    // Access specifically denied.
    return -1;
  }

  // Not a term manager file so return null.
  return;
}

/**
 * Prepare a batch definition that will process the file rows.
 */
function _dennis_term_manager_batch_init($file) {

  // Dry Run to validate and get operation list.
  $dryRun = new TermManagerDryRun();
  $dryRun->execute($file->uri);
  $operationList = $dryRun->getOperationList();

  if ($operationList->getErrorList()) {
    // Halt batch.
    return;
  }

  // Create file for reporting error.
  // - Use the same file name and change extenstion.
  $date = date('Y-m-d_H-i-s', REQUEST_TIME);
  $report_file_name = preg_replace("/[.](.*)/", "-" . $date . "-report.txt", $file->uri);
  $report_file = _dennis_term_manager_open_report($report_file_name);

  // Add each operation to the batch.
  $operations = array();
  foreach ($operationList as $i => $operationItem) {

    $options = array(
      'operation_item' => $operationItem,
      'report_fid' => $report_file->fid,
      'row' => $i,
    );

    $operations[] = array(
      'dennis_term_manager_queue_operation',
      array($options),
    );
  }

  $batch = array(
    'operations' => $operations,
    //'finished' => 'batch_dennis_term_manager_finished',
    'title' => t('Processing operations'),
    'init_message' => t('Process is starting.'),
    'progress_message' => t('Processed @current out of @total steps.'),
    'error_message' => t('Batch has encountered an error.'),
  );

  return $batch;
}

/**
 * Process operations and pass each to cron queue.
 */
function dennis_term_manager_queue_operation($options, &$context) {
  $operationItem =  $options['operation_item'];

  $baseData = array(
    'report_fid' => $options['report_fid'],
    'row' =>  $options['row'],
    'term_name' => $operationItem->term_name,
    'tid' => $operationItem->tid,
    'vid' => $operationItem->vid,
  );

  // Get the que to handle the.
  $q = DrupalQueue::get('dennis_term_manager_queue');

  switch ($operationItem->action) {
    case DENNIS_TERM_MANAGER_ACTION_MERGE:

      // Find all child terms of source term.
      $children = taxonomy_get_children($operationItem->tid);
      if (!empty($children)) {
        foreach ($children as $child) {
          // Change parent of each child term to target term.
          $childData = $baseData;
          $childData['action'] = DENNIS_TERM_MANAGER_ACTION_MOVE_PARENT;
          $childData['parent_tid'] =  $operationItem->target_tid;
          // Push each "merge move parent" action into the queue.
          $q->createItem($childData);
        }
      }

      // Get all nodes with source term reference.
      $nodes = _dennis_term_manager_get_associated_nodes($operationItem->tid);
      if (!empty($nodes)) {
        $nodeData = $baseData;
        $nodeData['action'] = DENNIS_TERM_MANAGER_ACTION_MERGE;
        $nodeData['target_tid'] = $operationItem->target_tid;
        $nodeData['target_vid'] = $operationItem->target_vid;
        $nodeData['target_field'] = $operationItem->target_field;
        // Create queue for each node.
        foreach ($nodes as $node) {
          $nodeData['nid'] = $node->nid;
          // Queue item for Merge action.
          $q->createItem($nodeData);
        }
      }

      // Delete term once after nodes have been assigned to the target.
      $deleteData = $baseData;
      $deleteData['action'] = DENNIS_TERM_MANAGER_ACTION_DELETE;
      $q->createItem($deleteData);

      break;

    case DENNIS_TERM_MANAGER_ACTION_MOVE_PARENT:
      $data = $baseData;
      $data['action'] = $operationItem->action;
      $data['parent_tid'] = $operationItem->parent_tid;
      $data['parent_term_name'] = $operationItem->parent_term_name;
      $q->createItem($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_CREATE:
      $data = $baseData;
      $data['action'] = $operationItem->action;
      $data['parent_tid'] = $operationItem->parent_tid;
      $data['parent_term_name'] = $operationItem->parent_term_name;
      $q->createItem($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_DELETE:

      // Get all nodes with source term reference.
      $nodes = _dennis_term_manager_get_associated_nodes($operationItem->tid);
      if (!empty($nodes)) {
        $nodeData = $baseData;
        $nodeData['action'] = $operationItem->action;
        $nodeData['target_tid'] = $operationItem->target_tid;
        // Create queue for each node.
        foreach ($nodes as $node) {
          $nodeData['nid'] = $node->nid;
          // Queue item for Merge action.
          $q->createItem($nodeData);
        }
      }

      $data = $baseData;
      $data['action'] = $operationItem->action;
      $q->createItem($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_RENAME:
      $data = $baseData;
      $data['action'] = $operationItem->action;
      $data['new_name'] = $operationItem->new_name;
      $q->createItem($data);
      break;

    default:
      continue 2;
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function dennis_term_manager_cron_queue_info() {
  $queues['dennis_term_manager_queue'] = array(
    'worker callback' => 'dennis_term_manager_process_queue_item',
    'time' => 60,
  );
  return $queues;
}

/**
 * Process the queue of terms, if any. Does what drupal_cron_run() does.
 *
 * @see drupal_cron_run()
 * 
 * @param int $max_time
 *   No of seconds
 */
function dennis_term_manager_process_queue($max_time = 15) {
  $end = time() + $max_time;
  $queue = DrupalQueue::get('dennis_term_manager_queue');
  while (time() < $end && ($item = $queue->claimItem())) {
    dennis_term_manager_process_queue_item($item->data);
    $queue->deleteItem($item);
  }
}

/**
 * Perform action on each queue item.
 * 
 * @param array $data
 *   An array containing source and target taxonomy term data
 *   
 */
function dennis_term_manager_process_queue_item($data) {
  // Process each row against their action column and validate their data.
  switch (strtolower($data['action'])) {
    case DENNIS_TERM_MANAGER_ACTION_CREATE:
      include_once 'dennis_term_manager_action_create.inc';
      _dennis_term_manager_process_action_create($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_DELETE:
      include_once 'dennis_term_manager_action_delete.inc';
      _dennis_term_manager_process_action_delete($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_RENAME:
      include_once 'dennis_term_manager_action_rename.inc';
      _dennis_term_manager_process_action_rename($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_MERGE:
      include_once 'dennis_term_manager_action_merge.inc';
      _dennis_term_manager_process_action_merge($data);
      break;

    case DENNIS_TERM_MANAGER_ACTION_MOVE_PARENT:
      include_once 'dennis_term_manager_action_move_parent.inc';
      _dennis_term_manager_process_action_move_parent($data);
      break;

    default:
      // Invalid Action.
      drupal_set_message(t("Invalid action in row @row", array(
        '@row' => $data['row'],
      )));
      break;
  }
}

/**
 * Helper to get vocabulary.
 *
 * @param : $vocabulary_name
 *   Vocabulary Name
 *
 * @return : $vocabulary
 *   array containing vocabulary
 */
function _dennis_term_manager_get_vocabulary($vocabulary_name) {
  // Return static if possible.
  $vocabulary = &drupal_static(__FUNCTION__ . $vocabulary_name, FALSE);
  if ($vocabulary !== FALSE) {
    return $vocabulary;
  }

  // Get vocabulary by vocabulary name.
  $query = db_select('taxonomy_vocabulary', 'tv');
  $query->fields('tv', array(
    'machine_name',
    'vid',
  ));
  $query->condition('tv.name', $vocabulary_name, '=');
  $vocabulary = $query->execute()->fetchObject();
  return $vocabulary;
}

/**
 * Helper to retrieve nodes associated with Term ID.
 *
 * @param : $tid
 *   Taxonomy Term ID.
 *   
 * @return array 
 *   List of nodes.
 */
function _dennis_term_manager_get_associated_nodes($tid) {
  // Get nodes from taxonomy_index using target term tid.
  $query = db_select('taxonomy_index', 'ti');
  $query->fields('ti', array(
    'nid',
  ));
  $query->condition('ti.tid', $tid, '=');
  $nodes = $query->execute()->fetchAll();
  return $nodes;
}

/**
 * Helper to get term ID.
 *
 * @param : $term_name
 *   Taxonomy Term Name
 * @param : $vid
 *   Vocabulary Machine Name
 *   
 * @return int 
 *   Taxonomy Term ID or false in case not found
 */
function _dennis_term_manager_get_tid($term_name, $vid) {
  $vocabulary = taxonomy_vocabulary_load($vid);
  $term_name = _dennis_term_manager_decode_specific_chars($term_name);
  if ($term = taxonomy_get_term_by_name($term_name, $vocabulary->machine_name)) {
    $first_term = array_values($term);
    return $first_term[0]->tid;
  }
}

/**
 * Helper to check if source term is the parent of target term.
 *
 * @param int $target_term_id 
 *   Taxonomy Term id
 * @param int $term_id
 *   Taxonomy Term Id
 */
function _dennis_term_manager_term_is_parent($target_term_id, $term_id) {
  $ancestors = taxonomy_get_parents_all($target_term_id);
  // If there are no parents, it's already level 1 term.
  if (empty($ancestors)) {
    return TRUE;
  }
  // Overwise check the term for not beeing checked term itself.
  else {
    foreach ($ancestors as $value) {
      if ($term_id == $value->tid) {
        return FALSE;
      }
    }
  }

  return TRUE;
}

/**
 * Helper to write errors in report file.
 *
 * @param: $file_name
 *   URI of file
 * @param: $error_message
 *   Error Message.
 */
function _dennis_term_manager_write_report($fid, $error_message) {
  $file = file_load($fid);
  if (isset($file->uri) && ($report_handle = fopen($file->uri, "a")) != FALSE) {
    fwrite($report_handle, $error_message . PHP_EOL);
    fclose($report_handle);
    file_save($file);
  }
  else {
    // Report on watchdog.
    watchdog('DENNIS_TERM_MANAGER', t('Not able to write in report file. error %message'), array(
      '%message' => $error_message,
    ));
  }
}

/**
 * Opens a new report and return fid.
 *
 * @param $file_path
 */
function _dennis_term_manager_open_report($file_path) {
  // Create new managed file.
  $file = file_save_data('', $file_path, FILE_EXISTS_RENAME);
  // Add file usage.
  file_usage_add($file, 'dennis_term_manager', 'dennis_term_manager_csv_file', 1);
  return $file;
}

/**
 * Helper function, to decode encoded string.
 *
 * We don't want to decode all the string, so let's take in consideration
 * encoded chars.
 */
function _dennis_term_manager_decode_specific_chars($string) {
  return str_replace('&amp;', '&', $string);
}

/**
 * Get allowed vocabularies for specified field.
 *
 * @param $field_name
 */
function _dennis_term_manager_get_field_allowed_vocabularies($field_name) {
  // Return cached allowed vocabularies if available.
  $allowed_vocabularies = &drupal_static(__FUNCTION__ . $field_name, FALSE);
  if ($allowed_vocabularies !== FALSE) {
    return $allowed_vocabularies;
  }

  // Build arry of allowed vocabularies.
  $allowed_vocabularies = array();
  if ($field_info = field_info_field($field_name)) {
    if (isset($field_info['settings']['allowed_values']) && is_array($field_info['settings']['allowed_values'])) {
      foreach ($field_info['settings']['allowed_values'] as $allowed_value) {
        if (isset($allowed_value['vocabulary'])) {
          if ($vocabulary = taxonomy_vocabulary_machine_name_load($allowed_value['vocabulary'])) {
            $allowed_vocabularies[$vocabulary->vid] = $allowed_value['vocabulary'];
          }
        }
      }
    }
  }

  return $allowed_vocabularies;
}

/**
 * Get allowed fields for specified vocabulary.
 *
 * @param $vid
 */
function _dennis_term_manager_get_vocabulary_allowed_fields($vid) {
  // Return cached allowed fields if available.
  $allowed_fields = &drupal_static(__FUNCTION__ . $vid, FALSE);
  if ($allowed_fields !== FALSE) {
    return $allowed_fields;
  }

  // Build array of allowed fields for this vocabulary.
  $allowed_fields = array();
  $taxonomy_fields = field_read_fields(array('type' => 'taxonomy_term_reference'));
  foreach ($taxonomy_fields as $field_info) {
    $allowed_vocabularies = _dennis_term_manager_get_field_allowed_vocabularies($field_info['field_name']);
    if (isset($allowed_vocabularies[$vid])) {
      $allowed_fields[] = $field_info['field_name'];
    }
  }

  return $allowed_fields;
}

/**
 * Get the process currently running.
 */
function dennis_term_manager_get_current_queue_item() {
  $query = db_query_range('SELECT data, item_id
    FROM {queue} q
    WHERE
      expire = 0 AND
      name = :name
    ORDER BY created ASC',
    0, 1,
    array(':name' => 'dennis_term_manager_queue')
  );

  if ($item = $query->fetchObject()) {
    $item->data = unserialize($item->data);
    return $item;
  }
}

/**
 * CSV/TSV files should always have these columns.
 */
function dennis_term_manager_default_columns() {
  return array(
    'vocabulary_name',
    'term_name',
    'node_count',
    'parent_term_name',
    'action',
    'target_term_name',
    'target_vocabulary_name',
    'target_field',
    'new_name',
  );
}
